; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\obj\uart_io.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\uart_io.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I"..\CAN TEST" -I.\RTE -I.\RTE\Device -I.\RTE\Device\MDR1986BE92 -I.\rtos -I.\rtos\include -I.\RTE\Device\MDR1986BE92 -I.\RTE\_Target_1 -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Config -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\CoreSupport -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 --omf_browse=.\obj\uart_io.crf uart_io.c]
                          THUMB

                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=2

                  fgetc PROC
;;;136      */
;;;137    int fgetc(FILE *f)
000000  b538              PUSH     {r3-r5,lr}
;;;138    {
000002  4604              MOV      r4,r0
;;;139        uint8_t ch;
;;;140        
;;;141        if (xQueueReceive(stdin_queue, &ch, portMAX_DELAY) == pdPASS)
000004  2300              MOVS     r3,#0
000006  1e5a              SUBS     r2,r3,#1
000008  4669              MOV      r1,sp
00000a  4805              LDR      r0,|L1.32|
00000c  6800              LDR      r0,[r0,#0]  ; stdin_queue
00000e  f7fffffe          BL       xQueueGenericReceive
000012  2801              CMP      r0,#1
000014  d102              BNE      |L1.28|
;;;142        {
;;;143            return((int)ch);
000016  f89d0000          LDRB     r0,[sp,#0]
                  |L1.26|
;;;144        }
;;;145        else
;;;146        {
;;;147            return ((int)'\0');
;;;148        }
;;;149    }
00001a  bd38              POP      {r3-r5,pc}
                  |L1.28|
00001c  2000              MOVS     r0,#0                 ;147
00001e  e7fc              B        |L1.26|
;;;150    
                          ENDP

                  |L1.32|
                          DCD      stdin_queue

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;124      */
;;;125    int fputc(int ch, FILE *f)
000000  b538              PUSH     {r3-r5,lr}
;;;126    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;127        char item = (char)ch;
000006  b2e0              UXTB     r0,r4
000008  9000              STR      r0,[sp,#0]
;;;128        
;;;129        xQueueSendToBack(stdout_queue, &item, 0);
00000a  2300              MOVS     r3,#0
00000c  461a              MOV      r2,r3
00000e  4669              MOV      r1,sp
000010  4802              LDR      r0,|L2.28|
000012  6800              LDR      r0,[r0,#0]  ; stdout_queue
000014  f7fffffe          BL       xQueueGenericSend
;;;130        
;;;131        return ch;
000018  4620              MOV      r0,r4
;;;132    }
00001a  bd38              POP      {r3-r5,pc}
;;;133    
                          ENDP

                  |L2.28|
                          DCD      stdout_queue

                          AREA ||i.stdout_flush||, CODE, READONLY, ALIGN=2

                  stdout_flush PROC
;;;155      */
;;;156    void stdout_flush(void)
000000  b570              PUSH     {r4-r6,lr}
;;;157    {  
;;;158        static uint8_t buf[STDOUT_QUEUE_SIZE];
;;;159        uint32_t length = 0;
000002  2400              MOVS     r4,#0
;;;160    	  uint32_t i = 0;
000004  2500              MOVS     r5,#0
;;;161        
;;;162        if (xQueueReceive(stdout_queue, &buf[length], portMAX_DELAY) == pdPASS)
000006  4815              LDR      r0,|L3.92|
000008  1901              ADDS     r1,r0,r4
00000a  2300              MOVS     r3,#0
00000c  1e5a              SUBS     r2,r3,#1
00000e  4814              LDR      r0,|L3.96|
000010  6800              LDR      r0,[r0,#0]  ; stdout_queue
000012  f7fffffe          BL       xQueueGenericReceive
000016  2801              CMP      r0,#1
000018  d11e              BNE      |L3.88|
;;;163        {
;;;164    			// Очистка очереди путем передачи накопленных данных в буффер
;;;165    			  while((++length < STDOUT_QUEUE_SIZE) && 
00001a  bf00              NOP      
                  |L3.28|
00001c  1c60              ADDS     r0,r4,#1
00001e  4604              MOV      r4,r0
000020  f5b06f00          CMP      r0,#0x800
000024  d209              BCS      |L3.58|
;;;166                (xQueueReceive(stdout_queue, &buf[length], 0) == pdPASS));
000026  480d              LDR      r0,|L3.92|
000028  1901              ADDS     r1,r0,r4
00002a  2300              MOVS     r3,#0
00002c  461a              MOV      r2,r3
00002e  480c              LDR      r0,|L3.96|
000030  6800              LDR      r0,[r0,#0]  ; stdout_queue
000032  f7fffffe          BL       xQueueGenericReceive
000036  2801              CMP      r0,#1
000038  d0f0              BEQ      |L3.28|
                  |L3.58|
;;;167            /* Отправка данных из буффера по UART */
;;;168    				while(i!=length)
00003a  e00b              B        |L3.84|
                  |L3.60|
;;;169    				{
;;;170    					  /* Ожидание флага освобождения буфера передачи (TXFE) */
;;;171    					while (UART_GetFlagStatus(UART_IO, UART_FLAG_TXFE) != SET);
00003c  bf00              NOP      
                  |L3.62|
00003e  2180              MOVS     r1,#0x80
000040  4808              LDR      r0,|L3.100|
000042  f7fffffe          BL       UART_GetFlagStatus
000046  2801              CMP      r0,#1
000048  d1f9              BNE      |L3.62|
;;;172    					// Отправка одного символа по UART
;;;173    					UART_SendData(UART_IO, buf[i]);
00004a  4804              LDR      r0,|L3.92|
00004c  5d41              LDRB     r1,[r0,r5]
00004e  4805              LDR      r0,|L3.100|
000050  f7fffffe          BL       UART_SendData
                  |L3.84|
000054  42a5              CMP      r5,r4                 ;168
000056  d1f1              BNE      |L3.60|
                  |L3.88|
;;;174    				}
;;;175    				
;;;176           
;;;177        }
;;;178    }
000058  bd70              POP      {r4-r6,pc}
;;;179    
                          ENDP

00005a  0000              DCW      0x0000
                  |L3.92|
                          DCD      buf
                  |L3.96|
                          DCD      stdout_queue
                  |L3.100|
                          DCD      0x40038000

                          AREA ||i.uart_io_init||, CODE, READONLY, ALIGN=2

                  uart_io_init PROC
;;;38       */
;;;39     void uart_io_init(void)
000000  b500              PUSH     {lr}
;;;40     {
000002  b087              SUB      sp,sp,#0x1c
;;;41     	     /* Структура для настройки портов ввода/вывода, используемых в UART */
;;;42         PORT_InitTypeDef Port_InitStructure;
;;;43     	   /* Структура для настройки UART */
;;;44         UART_InitTypeDef UART_InitStructure;
;;;45         /* Инициализация ножек RX и TX */
;;;46         /* Разрешение тактирования портов с ножками RX и TX */
;;;47         RST_CLK_PCLKcmd(UART_IO_RX_PORT_CLK, ENABLE);
000004  2101              MOVS     r1,#1
000006  0748              LSLS     r0,r1,#29
000008  f7fffffe          BL       RST_CLK_PCLKcmd
;;;48         RST_CLK_PCLKcmd(UART_IO_TX_PORT_CLK, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0748              LSLS     r0,r1,#29
000010  f7fffffe          BL       RST_CLK_PCLKcmd
;;;49        
;;;50         /* Заполнение общих полей структуры Port_InitStructure */
;;;51         /* Подтяжка к питанию отключена */
;;;52         Port_InitStructure.PORT_PULL_UP = PORT_PULL_UP_OFF;
000014  2000              MOVS     r0,#0
000016  f88d0013          STRB     r0,[sp,#0x13]
;;;53         /* Подтяжка к нулю отключена */
;;;54         Port_InitStructure.PORT_PULL_DOWN = PORT_PULL_DOWN_OFF;
00001a  f88d0014          STRB     r0,[sp,#0x14]
;;;55         /* Триггер Шмитта отключен */
;;;56         Port_InitStructure.PORT_PD_SHM = PORT_PD_SHM_OFF;
00001e  f88d0015          STRB     r0,[sp,#0x15]
;;;57         /* Режим работы выхода – управляемый драйвер */
;;;58         Port_InitStructure.PORT_PD = PORT_PD_DRIVER;
000022  f88d0016          STRB     r0,[sp,#0x16]
;;;59         /* Режим работы входного фильтра -  фильтр выключен */
;;;60         Port_InitStructure.PORT_GFEN = PORT_GFEN_OFF;
000026  f88d0017          STRB     r0,[sp,#0x17]
;;;61         /* Переопределенная альтернативная функция порта */
;;;62         Port_InitStructure.PORT_FUNC = PORT_FUNC_OVERRID;
00002a  2003              MOVS     r0,#3
00002c  f88d0018          STRB     r0,[sp,#0x18]
;;;63         /* Скорость нарастания/спада - максимально быстрый фронт */
;;;64         Port_InitStructure.PORT_SPEED = PORT_SPEED_MAXFAST;
000030  f88d0019          STRB     r0,[sp,#0x19]
;;;65         /* Режим работы - цифровой вход/выход */
;;;66         Port_InitStructure.PORT_MODE = PORT_MODE_DIGITAL;
000034  2001              MOVS     r0,#1
000036  f88d001a          STRB     r0,[sp,#0x1a]
;;;67     
;;;68         /* Настройка UART RX на ввод */
;;;69         /* Настройка ножки порта на ввод */
;;;70         Port_InitStructure.PORT_OE = PORT_OE_IN;
00003a  2000              MOVS     r0,#0
00003c  f88d0012          STRB     r0,[sp,#0x12]
;;;71         /* Указываем номер ножки,которую будет инициализировать */
;;;72         Port_InitStructure.PORT_Pin = UART_IO_RX_PIN;
000040  2001              MOVS     r0,#1
000042  f8ad0010          STRH     r0,[sp,#0x10]
;;;73         /* Инициализация ножки */
;;;74         PORT_Init(UART_IO_RX_PORT, &Port_InitStructure); 
000046  a904              ADD      r1,sp,#0x10
000048  4821              LDR      r0,|L4.208|
00004a  f7fffffe          BL       PORT_Init
;;;75         
;;;76         /* Настройка UART TX на вывод */
;;;77         /* Настройка ножки порта на вывод */
;;;78         Port_InitStructure.PORT_OE = PORT_OE_OUT;
00004e  2001              MOVS     r0,#1
000050  f88d0012          STRB     r0,[sp,#0x12]
;;;79         /* Указываем номер ножки,которую будет инициализировать */
;;;80         Port_InitStructure.PORT_Pin = UART_IO_TX_PIN;
000054  2002              MOVS     r0,#2
000056  f8ad0010          STRH     r0,[sp,#0x10]
;;;81         /* Инициализация ножки */
;;;82         PORT_Init(UART_IO_TX_PORT, &Port_InitStructure); 
00005a  a904              ADD      r1,sp,#0x10
00005c  481c              LDR      r0,|L4.208|
00005e  f7fffffe          BL       PORT_Init
;;;83         
;;;84         /* Инициализация UART */
;;;85     
;;;86         /* Разрешение тактирования UART */
;;;87         RST_CLK_PCLKcmd(UART_IO_CLK, ENABLE);
000062  2101              MOVS     r1,#1
000064  2080              MOVS     r0,#0x80
000066  f7fffffe          BL       RST_CLK_PCLKcmd
;;;88     
;;;89         /* Настройка делителя тактовой частоты UART */
;;;90         UART_BRGInit(UART_IO, UART_HCLKdiv1);
00006a  2100              MOVS     r1,#0
00006c  4819              LDR      r0,|L4.212|
00006e  f7fffffe          BL       UART_BRGInit
;;;91         /*Разрешение прерывания для UART*/
;;;92     		NVIC_EnableIRQ(UART_IO_IRQ);
000072  2007              MOVS     r0,#7
000074  2800              CMP      r0,#0
000076  db09              BLT      |L4.140|
000078  f000021f          AND      r2,r0,#0x1f
00007c  2101              MOVS     r1,#1
00007e  4091              LSLS     r1,r1,r2
000080  0942              LSRS     r2,r0,#5
000082  0092              LSLS     r2,r2,#2
000084  f10222e0          ADD      r2,r2,#0xe000e000
000088  f8c21100          STR      r1,[r2,#0x100]
                  |L4.140|
00008c  bf00              NOP      
;;;93      
;;;94     
;;;95         /* Заполнение полей структуры UART_InitStructure */
;;;96         /* Скорость передачи */
;;;97         UART_InitStructure.UART_BaudRate                = UART_IO_BAUDRATE;
00008e  f44f30e1          MOV      r0,#0x1c200
000092  9000              STR      r0,[sp,#0]
;;;98         /* Количество бит данных - 8 */
;;;99         UART_InitStructure.UART_WordLength              = UART_WordLength8b;
000094  2060              MOVS     r0,#0x60
000096  f8ad0004          STRH     r0,[sp,#4]
;;;100        /* Количество стоп бит - 1 */
;;;101        UART_InitStructure.UART_StopBits                = UART_StopBits1;
00009a  2000              MOVS     r0,#0
00009c  f8ad0006          STRH     r0,[sp,#6]
;;;102        /* Без контроля бита паритета */
;;;103        UART_InitStructure.UART_Parity                  = UART_Parity_No;
0000a0  f8ad0008          STRH     r0,[sp,#8]
;;;104        /* Буфер FIFO отключен */
;;;105        UART_InitStructure.UART_FIFOMode                = UART_FIFO_OFF;
0000a4  f8ad000a          STRH     r0,[sp,#0xa]
;;;106        /* Включаем передатчик и приемник */
;;;107        UART_InitStructure.UART_HardwareFlowControl     = 
0000a8  f44f7040          MOV      r0,#0x300
0000ac  f8ad000c          STRH     r0,[sp,#0xc]
;;;108            UART_HardwareFlowControl_RXE |
;;;109            UART_HardwareFlowControl_TXE;
;;;110    
;;;111        /* Инициализация UART */
;;;112        UART_Init(UART_IO, &UART_InitStructure);
0000b0  4669              MOV      r1,sp
0000b2  4808              LDR      r0,|L4.212|
0000b4  f7fffffe          BL       UART_Init
;;;113        /*Разрешение прерывания по приему*/
;;;114    		UART_ITConfig(UART_IO,UART_IT_RX, ENABLE);
0000b8  2201              MOVS     r2,#1
0000ba  2110              MOVS     r1,#0x10
0000bc  4805              LDR      r0,|L4.212|
0000be  f7fffffe          BL       UART_ITConfig
;;;115        /* Разрешение работы UART */
;;;116        UART_Cmd(UART_IO, ENABLE);
0000c2  2101              MOVS     r1,#1
0000c4  4803              LDR      r0,|L4.212|
0000c6  f7fffffe          BL       UART_Cmd
;;;117    }
0000ca  b007              ADD      sp,sp,#0x1c
0000cc  bd00              POP      {pc}
;;;118    
                          ENDP

0000ce  0000              DCW      0x0000
                  |L4.208|
                          DCD      0x400e8000
                  |L4.212|
                          DCD      0x40038000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  buf
                          %        2048

;*** Start embedded assembler ***

#line 1 "uart_io.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_uart_io_c_3f6c88ae____REV16|
#line 467 "C:\\Users\\AN-Mi\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.5.1\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___9_uart_io_c_3f6c88ae____REV16| PROC
#line 468

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_uart_io_c_3f6c88ae____REVSH|
#line 482
|__asm___9_uart_io_c_3f6c88ae____REVSH| PROC
#line 483

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_uart_io_c_3f6c88ae____RRX|
#line 669
|__asm___9_uart_io_c_3f6c88ae____RRX| PROC
#line 670

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
